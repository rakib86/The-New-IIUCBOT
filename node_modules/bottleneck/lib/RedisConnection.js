"use strict";

// Generated by CoffeeScript 2.2.4
(function () {
  var RedisConnection, Scripts;

  Scripts = require("./Scripts");

  RedisConnection = class RedisConnection {
    constructor(clientOptions, Promise, Events) {
      var Redis;
      this.clientOptions = clientOptions;
      this.Promise = Promise;
      this.Events = Events;
      Redis = eval("require")("redis"); // Obfuscated or else Webpack/Angular will try to inline the optional redis module
      this.client = Redis.createClient(this.clientOptions);
      this.subClient = Redis.createClient(this.clientOptions);
      this.pubsubs = {};
      this.shas = {};
      this.ready = new this.Promise((resolve, reject) => {
        var count, done, errorListener;
        errorListener = e => {
          [this.client, this.subClient].forEach(client => {
            return client.removeListener("error", errorListener);
          });
          return reject(e);
        };
        count = 0;
        done = () => {
          count++;
          if (count === 2) {
            [this.client, this.subClient].forEach(client => {
              client.removeListener("error", errorListener);
              return client.on("error", e => {
                return this.Events.trigger("error", [e]);
              });
            });
            return resolve();
          }
        };
        this.client.on("error", errorListener);
        this.client.on("ready", function () {
          return done();
        });
        this.subClient.on("error", errorListener);
        this.subClient.on("ready", () => {
          this.subClient.on("psubscribe", function () {
            return done();
          });
          return this.subClient.psubscribe("bottleneck_*");
        });
        return this.subClient.on("pmessage", (pattern, channel, message) => {
          var base;
          return typeof (base = this.pubsubs)[channel] === "function" ? base[channel](message) : void 0;
        });
      }).then(() => {
        return this.Promise.all(Scripts.names.map(k => {
          return this._loadScript(k);
        }));
      }).then(() => {
        return this.Promise.resolve({
          client: this.client,
          subscriber: this.subClient
        });
      });
    }

    _loadScript(name) {
      return new this.Promise((resolve, reject) => {
        var payload;
        payload = Scripts.payload(name);
        return this.client.multi([["script", "load", payload]]).exec((err, replies) => {
          if (err != null) {
            return reject(err);
          }
          this.shas[name] = replies[0];
          return resolve(replies[0]);
        });
      });
    }

    addLimiter(instance, pubsub) {
      return this.pubsubs[`bottleneck_${instance.id}`] = pubsub;
    }

    removeLimiter(instance) {
      return delete this.pubsubs[`bottleneck_${instance.id}`];
    }

    scriptArgs(name, id, args, cb) {
      var keys;
      keys = Scripts.keys(name, id);
      return [this.shas[name], keys.length].concat(keys, args, cb);
    }

    scriptFn(name) {
      return this.client.evalsha.bind(this.client);
    }

    disconnect(flush) {
      this.client.end(flush);
      this.subClient.end(flush);
      return this.Promise.resolve();
    }

  };

  module.exports = RedisConnection;
}).call(undefined);